import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error



# --- Load and Prepare the Data ---

# Load data and convert the Date column to datetime format
df = pd.read_csv('dataset.csv')
df['Date'] = pd.to_datetime(df['Date'], format='%d-%m-%Y')

# Aggregate data to analyze staffing needs per department
dept_summary = df.groupby(['Date', 'Dept']).agg({
    'Cashiers': 'sum',
    'Sales_Associates': 'sum',
    'Stockers': 'sum',
    'Customer_Service': 'sum',
    'Total_Sales': 'sum',
    'footprint': 'first',
    'IsHoliday': 'max',
    'Week': 'first',
    'Month': 'first',
    'Type': 'first',
    'Size': 'first'
}).reset_index()


# Create temporal and lagged features
dept_summary['DayOfWeek'] = dept_summary['Date'].dt.dayofweek
dept_summary['IsWeekend'] = dept_summary['DayOfWeek'].isin([5, 6]).astype(int)
dept_summary['WeekOfMonth'] = (dept_summary['Date'].dt.day - 1) // 7 + 1
dept_summary['Quarter'] = dept_summary['Date'].dt.quarter

# Lag and rolling features for department-specific sales and footprint
dept_summary['Total_Sales_Lag1'] = dept_summary.groupby('Dept')['Total_Sales'].shift(1)
dept_summary['Total_Sales_Lag7'] = dept_summary.groupby('Dept')['Total_Sales'].shift(7)
dept_summary['footprint_Lag1'] = dept_summary.groupby('Dept')['footprint'].shift(1)
dept_summary['footprint_Lag7'] = dept_summary.groupby('Dept')['footprint'].shift(7)
dept_summary['Total_Sales_Rolling7'] = dept_summary.groupby('Dept')['Total_Sales'].transform(lambda x: x.rolling(window=7).mean())
dept_summary['footprint_Rolling7'] = dept_summary.groupby('Dept')['footprint'].transform(lambda x: x.rolling(window=7).mean())

# Drop NaNs generated by lag/rolling calculations
dept_data = dept_summary.dropna()



# --- Define Features and Target for Each Employee Role ---

features = [
    'Total_Sales', 'footprint', 'IsHoliday', 'Week', 'Month', 'Type', 'Size', 
    'DayOfWeek', 'IsWeekend', 'WeekOfMonth', 'Quarter', 
    'Total_Sales_Lag1', 'Total_Sales_Lag7', 'footprint_Lag1', 'footprint_Lag7', 
    'Total_Sales_Rolling7', 'footprint_Rolling7'
]

# Employee roles to predict
employee_roles = ['Cashiers', 'Sales_Associates', 'Stockers', 'Customer_Service']

# Dictionary to store models and predictions for each role
models = {}
predictions = {}



# --- Train a Model for Each Employee Role ---

for role in employee_roles:
    target = role
    
    # Split into features (X) and target (y)
    X = dept_data[features]
    y = dept_data[target]
    
    # Split into training and test sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
    
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    
    # Train the model
    model.fit(X_train, y_train)
    
    models[role] = model
    
    # Make predictions and store them
    y_pred = model.predict(X_test)
    predictions[role] = (y_test, y_pred)
    
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse)
    print(f"{role} - RMSE: {rmse}")




# --- Visualize Predicted vs Actual Staffing Needs for Each Role ---

for role in employee_roles:
    y_test, y_pred = predictions[role]
    
    plt.figure(figsize=(14, 7))
    
    # Plot the actual employee count
    plt.plot(dept_data['Date'].iloc[-len(y_test):], y_test, label=f'Actual {role}', color='blue')
    
    # Plot the predicted employee count
    plt.plot(dept_data['Date'].iloc[-len(y_test):], y_pred, label=f'Predicted {role}', color='red', linestyle='dashed')
    
    plt.title(f"Actual vs Predicted {role} Count Over Time")
    plt.xlabel("Date")
    plt.ylabel(f"{role} Count")
    plt.legend()
    plt.show()

